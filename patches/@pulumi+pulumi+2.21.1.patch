diff --git a/node_modules/@pulumi/pulumi/runtime/closure/v8_v11andHigher.js b/node_modules/@pulumi/pulumi/runtime/closure/v8_v11andHigher.js
index 5041c52..cb7d021 100644
--- a/node_modules/@pulumi/pulumi/runtime/closure/v8_v11andHigher.js
+++ b/node_modules/@pulumi/pulumi/runtime/closure/v8_v11andHigher.js
@@ -23,6 +23,7 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 const util = require("util");
+const vm = require("vm");
 const v8Hooks = require("./v8Hooks");
 /** @internal */
 function getFunctionLocationAsync(func) {
@@ -90,39 +91,58 @@ function lookupCapturedVariableValueAsync(func, freeVariable, throwOnFailure) {
     });
 }
 exports.lookupCapturedVariableValueAsync = lookupCapturedVariableValueAsync;
+// Isolated singleton context accessible from the inspector.
+// Used instead of `global` object to support executions with multiple V8 vm contexts as, e.g., done by Jest.
+const inflightContext = createContext();
+function createContext() {
+    return __awaiter(this, void 0, void 0, function* () {
+        const context = {
+            contextId: 0,
+            functions: {},
+            currentFunctionId: 0,
+            calls: {},
+            currentCallId: 0,
+        };
+        const session = yield v8Hooks.getSessionAsync();
+        const post = util.promisify(session.post);
+        // Create own context with known context id and functionsContext as `global`
+        yield post.call(session, "Runtime.enable");
+        const contextIdAsync = new Promise(resolve => {
+            session.once("Runtime.executionContextCreated", event => {
+                resolve(event.params.context.id);
+            });
+        });
+        vm.createContext(context);
+        context.contextId = yield contextIdAsync;
+        yield post.call(session, "Runtime.disable");
+        return context;
+    });
+}
 function getRuntimeIdForFunctionAsync(func) {
     return __awaiter(this, void 0, void 0, function* () {
         // In order to get information about an object, we need to put it in a well known location so
-        // that we can call Runtime.evaluate and find it.  To do this, we just make a special map on the
-        // 'global' object, and map from a unique-id to that object.  We then call Runtime.evaluate with
-        // an expression that then points to that unique-id in that global object.  The runtime will
-        // then find the object and give us back an internal id for it.  We can then query for
-        // information about the object through that internal id.
+        // that we can call Runtime.evaluate and find it.  To do this, we use a special map on the
+        // 'global' object of a vm context only used for this purpose, and map from a unique-id to that
+        // object.  We then call Runtime.evaluate with an expression that then points to that unique-id
+        // in that global object.  The runtime will then find the object and give us back an internal id
+        // for it.  We can then query for information about the object through that internal id.
         //
         // Note: the reason for the mapping object and the unique-id we create is so that we don't run
         // into any issues when being called asynchronously.  We don't want to place the object in a
         // location that might be overwritten by another call while we're asynchronously waiting for our
         // original call to complete.
-        //
-        // We also lazily initialize this in case pulumi has been loaded through another module and has
-        // already initialize this global state.
-        const globalAny = global;
-        if (!globalAny.__inflightFunctions) {
-            globalAny.__inflightFunctions = {};
-            globalAny.__currentFunctionId = 0;
-        }
-        // Place the function in a unique location off of the global object.
-        const currentFunctionName = "id" + globalAny.__currentFunctionId++;
-        globalAny.__inflightFunctions[currentFunctionName] = func;
+        const session = yield v8Hooks.getSessionAsync();
+        const post = util.promisify(session.post);
+        // Place the function in a unique location
+        const context = yield inflightContext;
+        const currentFunctionName = "id" + context.currentFunctionId++;
+        context.functions[currentFunctionName] = func;
+        const contextId = context.contextId;
+        const expression = `functions.${currentFunctionName}`;
         try {
-            const session = yield v8Hooks.getSessionAsync();
-            const post = util.promisify(session.post);
-            const expression = `global.__inflightFunctions.${currentFunctionName}`;
-            // This cast will become unnecessary when we move to TS 3.1.6 or above.  In that version they
-            // support typesafe '.call' calls.
-            const retType = yield post.call(session, "Runtime.evaluate", { expression });
+            const retType = yield post.call(session, "Runtime.evaluate", { contextId, expression });
             if (retType.exceptionDetails) {
-                throw new Error(`Error calling "Runtime.evaluate(${expression})": ` + retType.exceptionDetails.text);
+                throw new Error(`Error calling "Runtime.evaluate(${expression})" on context ${contextId}: ` + retType.exceptionDetails.text);
             }
             const remoteObject = retType.result;
             if (remoteObject.type !== "function") {
@@ -134,7 +154,7 @@ function getRuntimeIdForFunctionAsync(func) {
             return remoteObject.objectId;
         }
         finally {
-            delete globalAny.__inflightFunctions[currentFunctionName];
+            delete context.functions[currentFunctionName];
         }
     });
 }
@@ -160,18 +180,11 @@ function getValueForObjectId(objectId) {
         // memory as the bound 'this' value.  Inside that function declaration, we can then access
         // 'this' and assign it to a unique-id in a well known mapping table we have set up.  As above,
         // the unique-id is to prevent any issues with multiple in-flight asynchronous calls.
-        //
-        // We also lazily initialize this in case pulumi has been loaded through another module and has
-        // already initialize this global state.
-        const globalAny = global;
-        if (!globalAny.__inflightCalls) {
-            globalAny.__inflightCalls = {};
-            globalAny.__currentCallId = 0;
-        }
         const session = yield v8Hooks.getSessionAsync();
         const post = util.promisify(session.post);
+        const context = yield inflightContext;
         // Get an id for an unused location in the global table.
-        const tableId = "id" + globalAny.__currentCallId++;
+        const tableId = "id" + context.currentCallId++;
         // Now, ask the runtime to call a fictitious method on the scopes-array object.  When it
         // does, it will get the actual underlying value for the scopes array and bind it to the
         // 'this' value inside the function.  Inside the function we then just grab 'this' and
@@ -181,19 +194,19 @@ function getValueForObjectId(objectId) {
         const retType = yield post.call(session, "Runtime.callFunctionOn", {
             objectId,
             functionDeclaration: `function () {
-                global.__inflightCalls["${tableId}"] = this;
+                calls["${tableId}"] = this;
             }`,
         });
         if (retType.exceptionDetails) {
             throw new Error(`Error calling "Runtime.callFunction(${objectId})": `
                 + retType.exceptionDetails.text);
         }
-        if (!globalAny.__inflightCalls.hasOwnProperty(tableId)) {
+        if (!context.calls.hasOwnProperty(tableId)) {
             throw new Error(`Value was not stored into table after calling "Runtime.callFunctionOn(${objectId})"`);
         }
         // Extract value and clear our table entry.
-        const val = globalAny.__inflightCalls[tableId];
-        delete globalAny.__inflightCalls[tableId];
+        const val = context.calls[tableId];
+        delete context.calls[tableId];
         return val;
     });
 }
diff --git a/node_modules/@pulumi/pulumi/x/automation/cmd.js b/node_modules/@pulumi/pulumi/x/automation/cmd.js
index db07131..28754e7 100644
--- a/node_modules/@pulumi/pulumi/x/automation/cmd.js
+++ b/node_modules/@pulumi/pulumi/x/automation/cmd.js
@@ -40,7 +40,7 @@ function runPulumiCmd(args, cwd, additionalEnv, onOutput) {
     args.push("--non-interactive");
     const env = Object.assign(Object.assign({}, process.env), additionalEnv);
     return new Promise((resolve, reject) => {
-        const proc = childProcess.spawn("pulumi", args, { env, cwd });
+        const proc = childProcess.spawn("pulumi", args, { env, cwd, detached: true });
         // TODO: write to buffers and avoid concatenation
         let stdout = "";
         let stderr = "";
